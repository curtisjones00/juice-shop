import { Link } from "../../index";
/**
 * A list element inside of a markdown list. These are a little complex, but are split up into the following components,
 * for which there is a little bit of overlap:
 * - text: The text content immediately at the start of this list element.
 * - content: ALL subblocks under this list.
 * - children: ALL list elements under this list element; this trims out markdown blocks in between child list elements.
 */
export declare type MarkdownListElement = {
    symbol: string;
    task?: string;
    contents: MarkdownBlock[];
    children: MarkdownListElement[];
    text: MarkdownBlock[];
    line: number;
};
/** A markdown block inside of a markdown document. */
export declare type MarkdownBlock = {
    type: "paragraph";
    contents: string[];
    line: number;
} | {
    type: "frontmatter";
    contents: string[];
    line: number;
} | {
    type: "codeblock";
    delimiter: string;
    contents: string[];
    languages: string[];
    line: number;
    indented: boolean;
} | {
    type: "list";
    elements: MarkdownListElement[];
    line: number;
} | {
    type: "rule";
    symbol: string;
    count: number;
} | {
    type: "blockquote";
    contents: string[];
    line: number;
} | {
    type: "heading";
    level: number;
    text: string;
    line: number;
    ruling: boolean;
};
/**
 * Semantically significant markdown lines; lines are first parsed into this before being combined into blocks
 * to ease awkward context-dependent parts of Markdown.
 */
export declare type MarkdownLine = {
    type: "empty";
    indent: number;
} | {
    type: "text";
    text: string;
    indent: number;
} | {
    type: "list-element";
    symbol: string;
    task?: string;
    text: string;
    indent: number;
} | {
    type: "blockquote";
    text: string;
    indent: number;
} | {
    type: "heading";
    level: number;
    text: string;
    indent: number;
} | {
    type: "ruling";
    symbol: string;
    count: number;
    indent: number;
} | {
    type: "heading-ruling";
    symbol: string;
    count: number;
    indent: number;
} | {
    type: "codeblock";
    symbol: string;
    count: number;
    languages: string[];
    indent: number;
};
/** Count the amount of indentation at the start of line in spaces, returning [number of spaces, rest of line]. */
export declare function splitIndent(line: string): [number, string];
/** Reduce the indent (in spaces) on a string by the given amount. */
export declare function reduceIndent(line: string, amount: number): string;
/** Classify any line as a markdown line type which is passed on to a renderer. */
export declare function classifyLine(fullLine: string): MarkdownLine;
/** Parse a markdown file into a collection of markdown blocks. */
export declare function markdownFile(contents: string): MarkdownBlock[];
/** Parse markdown blocks from the given tokenizer that are at atleast the given indent. */
export declare function markdownBlocks(tokenizer: LineTokenizer, requiredIndent: number, checkFrontmatter?: boolean): MarkdownBlock[];
/**
 * Continually parse text lines regardless of indent until another line type is encountered; this
 * will also handle h1 '===' headers, producing an optional terminating 'header' object.
 */
export declare function markdownTextContinuation(tokenizer: LineTokenizer, initial: string[], lineno: number): MarkdownBlock[];
/** Consume a single list element in a list. */
export declare function markdownListElement(tokenizer: LineTokenizer, symbol: string, text: string, lineno: number, indent: number, task?: string): MarkdownListElement;
/** Repeatedly consume list elements until a full list is generated. */
export declare function markdownList(tokenizer: LineTokenizer, first: MarkdownListElement): MarkdownBlock;
/** Simple utility for splitting file contents efficiently into lines, tracking line numbers, and allowing iteration. */
declare class LineTokenizer {
    contents: string;
    private index;
    private lineNumber;
    private rn;
    private nextLine;
    constructor(contents: string);
    /** Peek at the next line in the input. */
    peek(): string | undefined;
    /** Advance the tokenizer to the next line and return the parsed line. */
    next(): string | undefined;
    /** Obtain the line number for the last-fetched line. */
    lineno(): number;
    /** Obtain the position that the tokenizer is in the input. */
    position(): number;
    /** Seek the tokenize to the given location. */
    seek(location: number): void;
    /** Take consecutive lines until the tokenizer runs out or the predicate returns false. */
    takeWhile(predicate: (line: string) => boolean, output?: string[]): string[];
    /**
     * Take elements while the given mapping on them returns non-undefined values; the output results will be the
     * result of the mapping.
     */
    takeMap(mapping: (line: string) => string | undefined, output?: string[]): string[];
    /** Return the next line in the input. */
    private rawNext;
}
/** Extract links from a line in the document. */
export declare function extractLinks(line: string): Link[];
/** Extract tags from a line in the document. */
export declare function extractTags(line: string): string[];
export {};
