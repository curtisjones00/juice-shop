/** Stores various indices on all files in the vault to make dataview generation fast. */
import { Result } from "../api/result";
import { DataObject } from "./value";
import { Component, MetadataCache, TAbstractFile, TFile, Vault } from "obsidian";
import { PageMetadata } from "./metadata";
import { DateTime } from "luxon";
import { FileImporter } from "./import/import-manager";
import { IndexEvtTriggerArgs } from "../typings/events";
/** A generic index which indexes variables of the form key -> value[], allowing both forward and reverse lookups. */
export declare class IndexMap {
    /** Maps key -> values for that key. */
    map: Map<string, Set<string>>;
    /** Cached inverse map; maps value -> keys that reference that value. */
    invMap: Map<string, Set<string>>;
    /** Create a new, empty index map. */
    constructor();
    /** Returns all values for the given key.  (This is unused except for tests - does it really need to be here?) */
    get(key: string): Set<string>;
    /** Returns all keys that reference the given key. Mutating the returned set is not allowed. */
    getInverse(value: string): Readonly<Set<string>>;
    set(key: string, values: Set<string>): this;
    /** Clears all values for the given key so they can be re-added. */
    delete(key: string): boolean;
    /** Rename all references to the given key to a new value. */
    rename(oldKey: string, newKey: string): boolean;
    /** Clear the entire index. */
    clear(): void;
}
/** Aggregate index which has several sub-indices and will initialize all of them. */
export declare class FullIndex extends Component {
    vault: Vault;
    metadataCache: MetadataCache;
    onChange: () => void;
    /** Generate a full index from the given vault. */
    static create(vault: Vault, metadata: MetadataCache, onChange: () => void): FullIndex;
    pages: Map<string, PageMetadata>;
    /** Map files -> tags in that file, and tags -> files. This version includes subtags. */
    tags: IndexMap;
    /** Map files -> exact tags in that file, and tags -> files. This version does not automatically add subtags. */
    etags: IndexMap;
    /** Map files -> linked files in that file, and linked file -> files that link to it. */
    links: IndexMap;
    /** Search files by path prefix. */
    prefix: PrefixIndex;
    /** Caches rows of CSV files. */
    csv: CsvCache;
    /**
     * The current "revision" of the index, which monotonically increases for every index change. Use this to determine
     * if you are up to date.
     */
    revision: number;
    /** Asynchronously parses files in the background using web workers. */
    importer: FileImporter;
    /** Construct a new index over the given vault and metadata cache. */
    private constructor();
    trigger(...args: IndexEvtTriggerArgs): void;
    /** Runs through the whole vault to set up initial file */
    initialize(): void;
    rename(file: TAbstractFile, oldPath: string): void;
    /** Queue a file for reloading; this is done asynchronously in the background and may take a few seconds. */
    reload(file: TFile): void;
    /** "Touch" the index, incrementing the revision number and causing downstream views to reload. */
    touch(): void;
    private reloadInternal;
}
/** Indexes files by their full prefix - essentially a simple prefix tree. */
export declare class PrefixIndex extends Component {
    vault: Vault;
    updateRevision: () => void;
    static create(vault: Vault, updateRevision: () => void): PrefixIndex;
    constructor(vault: Vault, updateRevision: () => void);
    /** Run through the whole vault to set up the initial prefix index. */
    initialize(): void;
    private walk;
    /** Get the list of all files under the given path. */
    get(prefix: string, filter?: (path: string) => boolean): Set<string>;
    /** Determines if the given path exists in the prefix index. */
    pathExists(path: string): boolean;
    /** Determines if the given prefix exists in the prefix index. */
    nodeExists(prefix: string): boolean;
    /**
     * Use the in-memory prefix index to convert a relative path to an absolute one.
     */
    resolveRelative(path: string, origin?: string): string;
}
/** Simple path filters which filter file types. */
export declare namespace PathFilters {
    function csv(path: string): boolean;
    function markdown(path: string): boolean;
}
/**
 * Caches in-use CSVs to make high-frequency reloads (such as actively looking at a document
 * that uses CSV) fast.
 */
export declare class CsvCache {
    vault: Vault;
    static CACHE_EXPIRY_SECONDS: number;
    cache: Map<string, {
        data: DataObject[];
        loadTime: DateTime;
    }>;
    cacheClearInterval: number;
    constructor(vault: Vault);
    /** Load a CSV file from the cache, doing a fresh load if it has not been loaded. */
    get(path: string): Promise<Result<DataObject[], string>>;
    /** Do the actual raw loading of a CSV path (which is either local or an HTTP request). */
    private load;
    /** Clear old entries in the cache (as measured by insertion time). */
    private clearOldEntries;
}
